<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Elipse Protocol</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #0a051e;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      color: white;
      overflow: hidden;
    }
    canvas {
      border: 2px solid #333;
      box-shadow: 0 0 20px rgba(0, 200, 255, 0.3);
    }
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(10, 5, 30, 0.95);
      text-align: center;
    }
    h1 {
      color: #ffdd66;
      font-size: 48px;
      margin-bottom: 10px;
      text-shadow: 0 0 10px rgba(255, 221, 102, 0.7);
    }
    h2 {
      color: #aaffcc;
      font-size: 24px;
      margin-bottom: 30px;
    }
    button {
      padding: 12px 30px;
      font-size: 18px;
      background: #0066cc;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #0099ff;
    }
  </style>
</head>
<body>
  <div id="startScreen">
    <h1>ELIPSE PROTOCOL</h1>
    <h2>Crônicas do Sinal Perdido</h2>
    <p>Use as setas ← → ou A/D para desviar das ameaças<br>e coletar fragmentos do Protocolo.</p>
    <button onclick="startGame()">INICIAR</button>
  </div>

  <div id="gameOverScreen" style="display: none;">
    <h1>PROTOCOLO CORROMPIDO</h1>
    <p>Fragmentos coletados: <span id="finalScore">0</span></p>
    <button onclick="restartGame()">TENTAR NOVAMENTE</button>
  </div>

  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Estado do jogo
    let gameState = 'start'; // 'start', 'playing', 'gameover'
    let score = 0;

    // Jogador
    const player = {
      x: canvas.width / 2,
      y: canvas.height - 50,
      radius: 15,
      speed: 5
    };

    // Listas
    let obstacles = [];
    let keys = [];

    // Controles
    const keysDown = {
      ArrowLeft: false,
      ArrowRight: false,
      a: false,
      d: false
    };

    window.addEventListener('keydown', (e) => {
      if (keysDown.hasOwnProperty(e.key)) keysDown[e.key] = true;
    });

    window.addEventListener('keyup', (e) => {
      if (keysDown.hasOwnProperty(e.key)) keysDown[e.key] = false;
    });

    // Geração de estrelas de fundo
    const stars = [];
    for (let i = 0; i < 100; i++) {
      stars.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        size: Math.random() * 1.5,
        speed: Math.random() * 0.5 + 0.1
      });
    }

    // Funções de desenho
    function drawPlayer() {
      ctx.fillStyle = 'rgba(0, 200, 255, 1)';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fill();

      // Aura
      for (let i = 1; i <= 3; i++) {
        ctx.strokeStyle = `rgba(0, 200, 255, ${0.2 / i})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.radius + i * 5, 0, Math.PI * 2);
        ctx.stroke();
      }
    }

    function drawObstacle(obs) {
      const pulse = Math.sin(Date.now() / 200) * 3;
      ctx.fillStyle = '#ff3232';
      ctx.beginPath();
      ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#ff9696';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(obs.x, obs.y, obs.radius + pulse, 0, Math.PI * 2);
      ctx.stroke();
    }

    function drawKey(key) {
      const angle = Date.now() / 200;
      ctx.fillStyle = '#32ff96';
      ctx.beginPath();
      ctx.arc(key.x, key.y, key.radius, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = '#32ff96';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(key.x, key.y);
      ctx.lineTo(
        key.x + Math.cos(angle) * 15,
        key.y + Math.sin(angle) * 15
      );
      ctx.stroke();
    }

    function drawStars() {
      ctx.fillStyle = 'white';
      stars.forEach(star => {
        ctx.globalAlpha = 0.7 + Math.sin(Date.now() / 1000 + star.x) * 0.3;
        ctx.beginPath();
        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
        ctx.fill();
      });
      ctx.globalAlpha = 1;
    }

    // Colisão
    function checkCollision(obj1, obj2) {
      const dx = obj1.x - obj2.x;
      const dy = obj1.y - obj2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < (obj1.radius + obj2.radius);
    }

    // Atualização do jogo
    function update() {
      if (gameState !== 'playing') return;

      // Movimento do jogador
      if (keysDown.ArrowLeft || keysDown.a) player.x -= player.speed;
      if (keysDown.ArrowRight || keysDown.d) player.x += player.speed;
      player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));

      // Spawn de obstáculos (a cada ~60 frames ≈ 1s)
      if (Math.random() < 0.02) {
        obstacles.push({
          x: Math.random() * (canvas.width - 40) + 20,
          y: -30,
          radius: Math.random() * 15 + 10,
          speed: Math.random() * 3 + 2
        });
      }

      // Spawn de chaves
      if (Math.random() < 0.008) {
        keys.push({
          x: Math.random() * (canvas.width - 30) + 15,
          y: -20,
          radius: 8,
          speed: Math.random() * 2 + 1.5
        });
      }

      // Atualizar obstáculos
      for (let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.y += obs.speed;
        if (obs.y > canvas.height + obs.radius) {
          obstacles.splice(i, 1);
        } else if (checkCollision(player, obs)) {
          gameOver();
        }
      }

      // Atualizar chaves
      for (let i = keys.length - 1; i >= 0; i--) {
        const key = keys[i];
        key.y += key.speed;
        if (key.y > canvas.height + key.radius) {
          keys.splice(i, 1);
        } else if (checkCollision(player, key)) {
          keys.splice(i, 1);
          score++;
        }
      }

      // Mover estrelas
      stars.forEach(star => {
        star.y += star.speed;
        if (star.y > canvas.height) star.y = 0;
      });
    }

    // Renderização
    function render() {
      ctx.fillStyle = '#0a051e';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawStars();
      obstacles.forEach(drawObstacle);
      keys.forEach(drawKey);
      drawPlayer();

      // HUD
      ctx.fillStyle = 'rgba(220, 220, 220, 1)';
      ctx.font = '20px Arial';
      ctx.fillText(`Elipse Keys: ${score}`, 20, 30);
    }

    // Loop principal
    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }

    // Controle de telas
    function startGame() {
      document.getElementById('startScreen').style.display = 'none';
      gameState = 'playing';
      score = 0;
      obstacles = [];
      keys = [];
      player.x = canvas.width / 2;
    }

    function gameOver() {
      gameState = 'gameover';
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverScreen').style.display = 'flex';
    }

    function restartGame() {
      document.getElementById('gameOverScreen').style.display = 'none';
      startGame();
    }

    // Iniciar loop
    gameLoop();
  </script>
</body>
</html>
